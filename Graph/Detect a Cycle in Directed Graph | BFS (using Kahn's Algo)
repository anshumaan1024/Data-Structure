// @gfg : Detect a cycle in directed graph

//---------------------------------------------------USING TOPOLOGICAL SORT | DFS-------------------------------------------------------

class Solution {
  public:
    // Function to detect cycle in a directed graph.
    bool isCyclic(int V, vector<int> adj[]) {
        
	    int indegree[V] = {0};
	    
	    for(int i=0; i<V; i++){
	        
	        for(auto it: adj[i])
	            indegree[it]++;
	    }
	    
	    vector<int> ans;
	    queue<int> q;
	    
	    // In, DAG there will exist at least one vertix with indegree = 0
	    for(int i=0; i<V; i++){
	        if(indegree[i]==0)
	            q.push(i);
	    }
	    
	    while(!q.empty()){
	        
	        int node = q.front();
	        q.pop();
	        
	        ans.push_back(node);
	        
	        for(auto it : adj[node] ){
	      
	            indegree[it]--;
	            if(indegree[it] == 0)
	                q.push(it);
	                
	        }
	    }
	    
	    if(ans.size()!=V)       return true;
	    
	    return false;
        
    }
};

//-----------------------------------------------TOPOLOGICAL SORT | BFS( KAHN'S ALGORITHM)---------------------------------------------

class Solution {
  public:
     vector<int> shortestPath(int N,int M, vector<vector<int>>& edges){
        
        // creating adjacency list
        vector<pair<int,int>> adj[N];
        for(int i=0; i<M; i++){
            
            int u = edges[i][0];
            int v = edges[i][1];
            int wt = edges[i][2];
            
            adj[u].push_back({v,wt});
            
        }
        
        // find topo sort using BFS (kahn's Algorithm)
        int indegree[N] = {0};
	    
	    // find indegree of each node
	    for(int i=0; i<N; i++){
	        
	        for(auto it: adj[i])
	            indegree[it.first]++;
	    }
	    
	    // store topological order
	    vector<int> ans;
	    queue<int> q;
	    
	    // In, DAG there will exist at least one vertix with indegree = 0
	    for(int i=0; i<N; i++){
	        if(indegree[i]==0)
	            q.push(i);
	    }
	    
	    while(!q.empty()){
	        
	        int node = q.front();
	        q.pop();
	        
	        ans.push_back(node);
	        
	        for(auto it : adj[node] ){
	      
	            indegree[it.first]--;
	            if(indegree[it.first] == 0)
	                q.push(it.first);
	                
	        }
	    }
        
        vector<int> dist(N,1e9);
        dist[0] = 0;
        
        
        for(int i=0; i<ans.size(); i++){
            
            int node = ans[i];
            
            for(auto it: adj[node]){
                
                int v = it.first;
                int wt = it.second;
                
                if( dist[node] + wt < dist[v])
                    dist[v] = dist[node] + wt;
                
            }
            
        }
        
        for(int i=0; i<N; i++){
            if(dist[i]==1e9)
                dist[i] = -1;
        }
        
        return dist;
        
    }
};

//-------------------------------------------------------------------------------------------------------------------------------------
